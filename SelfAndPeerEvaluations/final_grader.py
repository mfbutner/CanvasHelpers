"""Script to assign final, overall evaluation grades to students on Canvas

Contains a SelfAndPeerEvaluationFinalGrader class that handles the final grading
logic. Students will be assigned a final, overall grade on Canvas and have their
grade breakdown attached as a CSV file in the comments.
Requires an external JSON file of quiz questions to actually get question information.
Requires directory of quiz reports (generated by quiz_validator.py) to actually grade students on.

Typical Usage example:

    python3 final_grader.py @final_grader_args.txt --questions_file_path ./questions.json
"""
import argparse
import canvasapi
import datetime
import json
from jinja2 import Environment, FileSystemLoader
import pathlib
import os
import time
from utils import (
    create_base_arguement_parser,
    find_ag,
    make_unique_student_id_map,
    JsonDict,
)
from eval_individual_stats import EvalIndividualStats


class SelfAndPeerEvaluationFinalGrader:
    """Class that stores the final grading logic

    You can create an evaluation quiz by calling upload_final_grades_to_canvas("The Assignment Name", path_to_store_CSVs)

    Typical Usage example:
        grader = SelfAndPeerEvaluationFinalGrader(
            course,
            json_questions,
            quiz_reports_path,
            assignment_group_name,
        )
        grader.upload_final_grades_to_canvas(assignment_name, csv_reports_path)
    """

    def __init__(
        self,
        course: canvasapi.course.Course,
        json_questions: JsonDict,
        quiz_reports_path: str,
        assignment_group_name: str,
    ):
        self.course = course
        self.json_questions = json_questions
        self.quiz_reports_path = quiz_reports_path
        self.assignment_group = find_ag(course, assignment_group_name)
        students = course.get_users(
            enrollment_type=["student"], enrollment_state=["active"]
        )
        self.student_id_map = make_unique_student_id_map(students)

    def upload_final_grades_to_canvas(
        self, assignment_name: str, csv_report_path: str
    ) -> None:
        """
        upload's ALL students final evaluation grades onto Canvas and
        attaches a CSV file of the student's score breakdown to each submission
        :returns: None. Instead a final grade assignment is uploaded to Canvas and
                  a CSV file of a student's score breakdown is attached as a comment
        """
        files = []
        print("We'll be basing final grade off of these files:")
        print("These files will be processed in proper sorted order.")
        for filename in os.listdir(self.quiz_reports_path):
            print("   ", filename)
            files.append(os.path.join(self.quiz_reports_path, filename))
        files = sorted(files)

        individual_students_stats = []
        csv_files = {}
        # all students are using the same template anyway, so just load once
        cur_file_path = pathlib.Path(__file__)
        template_path = cur_file_path.parent.resolve(True) / "templates"
        environment = Environment(
            loader=FileSystemLoader(template_path), trim_blocks=True, lstrip_blocks=True
        )
        template = environment.get_template("report.csv")
        for unique_name, student in self.student_id_map.items():
            individual_students_stats.append(
                EvalIndividualStats(
                    unique_name, student.id, files, csv_report_path, template
                )
            )
            csv_files[student.id] = individual_students_stats[-1].csv_file_path

        now = datetime.datetime.now()
        assignment = self.course.create_assignment(
            assignment={
                "name": assignment_name,
                "description": "Your overall group work score based on the past Partner Evaluation assignments.",
                "assignment_group_id": self.assignment_group.id,
                "submission_types": ["none"],
                "points_possible": 100,
                "due_at": now,
                "lock_at": now,
                "unlock_at": now,
                "published": True,
            }
        )
        print("Uploading final grades and csv files to Canvas")
        print("This might take a while")
        upload_progress = assignment.submissions_bulk_update(
            grade_data={
                student.id: {"posted_grade": student.final_score}
                for student in individual_students_stats
            }
        )

        for student in individual_students_stats:
            student.write_to_csv()

        # wait for assignment to get submissions
        # if you don't wait, assignment.get_submissions() returns 0 submissions
        while upload_progress.workflow_state != "completed":
            time.sleep(5)  # just wait a bit before querying again
            upload_progress = upload_progress.query()

        valid_user_ids = [student.id for student in self.student_id_map.values()]
        for submission in assignment.get_submissions():
            if submission.user_id not in valid_user_ids:
                continue  # NOTE: submisssion is a "ghost submission" (from Canvas's Test Student, or pending invite), no way around this as of now
            submission.upload_comment(csv_files[submission.user_id])

        print("Finished upload!")


def create_arguement_parser() -> argparse.ArgumentParser:
    """
    creates the quiz_creator arguement parser
    :returns: quiz_creator arguement parser
    """
    parser = create_base_arguement_parser(
        prog="final_grader",
        description="Script to assign the final, overall evaluations grade to students\nRead args from file by prefixing file_name with '@' (e.g. python3 final_grader.py @my_args.txt)",
        prefix="@",
    )
    parser.add_argument(
        "--assignment_group_name",
        dest="assignment_group_name",
        type=str,
        required=True,
        help="The name of the assignment group for the "
        "final, overall evaluation assignment to be created under."
        "If the assignment group is not found, you will be asked to select it from a list of assignment groups.",
    )
    parser.add_argument(
        "--assignment_name",
        dest="assignment_name",
        type=str,
        required=True,
        help="The name of the final, overall evaluation assignment.",
    )
    parser.add_argument(
        "--quiz_reports_path",
        dest="quiz_reports_path",
        type=str,
        required=True,
        help="The path to the directory where the quiz reports are located.\nIt's ok if the directory path has a trailing `/`.",
    )
    parser.add_argument(
        "--csv_reports_path",
        dest="csv_reports_path",
        type=str,
        required=True,
        help="The path to the directory to store each students' CSV report.\nIt's ok if the directory path has a trailing `/`.",
    )
    return parser


if __name__ == "__main__":
    parser = create_arguement_parser()
    args = parser.parse_args()

    canvas = canvasapi.Canvas(args.canvas_url, args.canvas_key)
    course = canvas.get_course(args.course_id)
    with open(args.questions_path) as f:
        json_questions = json.load(f)

    grader = SelfAndPeerEvaluationFinalGrader(
        course,
        json_questions,
        args.quiz_reports_path,
        args.assignment_group_name,
    )
    grader.upload_final_grades_to_canvas(args.assignment_name, args.csv_reports_path)
